# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hLFyLuIgM2wABVA0goZzP9FTxj5VKer8
"""


import pandas as pd, numpy as np, json, math, random
from datetime import datetime, timedelta
from datasets import Dataset
from transformers import T5ForConditionalGeneration, T5TokenizerFast, Trainer, TrainingArguments
import json, numpy as np


print("\n" + "="*60)
print("Smart Financial Coach - Starting...")
print("="*60)
print("Generating synthetic transaction data (6 months)...")
rng = np.random.default_rng(42)
start = (pd.Timestamp.today().normalize().to_period("M")-6).to_timestamp()
dates = pd.date_range(start, periods=180, freq="D")

def add_row(rows, d, amt, merch, desc, cat):
    rows.append([d, float(amt), merch, desc, cat])

rows=[]

for d in dates:
    if d.weekday()==4 and (d.day % 14 in (0,1,2,3)):
        add_row(rows, d, 2200.00, "ACME Payroll", "Biweekly paycheck", "Income")

for d in dates:
    if rng.random()<0.06 and d.weekday()<5:
        add_row(rows, d, rng.normal(400,120), "Freelance Payment", "Freelance job", "Income")

for d in dates[::30]:
    add_row(rows, d, -1800.00, "Landlord LLC", "Monthly rent", "Rent")

for d in dates[14::30]:
    add_row(rows, d, -140.00, "PG&E", "Electricity & Gas", "Utilities")

for d in dates[6::30]:
    add_row(rows, d, -10.99, "Spotify", "Music subscription", "Subscription")
    add_row(rows, d, -15.49, "Netflix", "Streaming subscription", "Subscription")
    add_row(rows, d, -2.99, "iCloud Storage", "Storage plan", "Subscription")

gro = ["Trader Joe's","Whole Foods","Safeway"]
cof = ["Starbucks","Peet's Coffee"]
din = ["Chipotle","Sweetgreen","Shake Shack","Local Diner"]
tra = ["Caltrain","BART","Gas Station"]
rid = ["Uber","Lyft"]
shp = ["Target","Walmart","Amazon"]

for d in dates:
    add_row(rows, d, -abs(rng.normal(35,18)), rng.choice(gro), "Groceries & staples", "Groceries")
    if rng.random()<0.6:  add_row(rows, d, -abs(rng.normal(5.5,2)), rng.choice(cof), "Coffee", "Coffee")
    if rng.random()<0.3:  add_row(rows, d, -abs(rng.normal(18,8)), rng.choice(din), "Meal out", "Dining")
    if rng.random()<0.2:  add_row(rows, d, -abs(rng.normal(7,3)), rng.choice(tra), "Commute", "Transport")
    if rng.random()<0.1:  add_row(rows, d, -abs(rng.normal(22,9)), rng.choice(rid), "Ride", "Rideshare")
    if rng.random()<0.12: add_row(rows, d, -abs(rng.normal(40,25)), rng.choice(shp), "Household items", "Shopping")

# A couple anomalies
add_row(rows, dates[-12], -529.99, "Best Buy", "Noise-cancelling headphones", "Shopping")
add_row(rows, dates[-7], -899.00, "Delta Airlines", "Flight purchase", "Travel")

df = pd.DataFrame(rows, columns=["date","amount","merchant","description","category"])
df["date"] = pd.to_datetime(df["date"])
df = df.sort_values("date").reset_index(drop=True)
df["month"] = df["date"].dt.to_period("M").dt.to_timestamp()
print(f"‚úÖ Generated {len(df)} transactions across {len(df['month'].unique())} months")


def month_cat_sums(g):
    s = g[g["amount"]<0].groupby("category")["amount"].apply(lambda x:-x.sum()).sort_values(ascending=False)
    return s.to_dict()

def find_subs(frame):
    """Detect recurring subscriptions"""
    out=[]
    for m,g in frame.groupby("merchant"):
        if len(g)<3: continue
        d = g.sort_values("date")["date"].diff().dt.days.dropna()
        if len(d)==0: continue
        gap_ok = d.std()<8 and d.mean()>=20
        amt = g["amount"].abs()
        amt_ok = amt.std()<max(5, 0.25*amt.mean())
        if gap_ok and amt_ok: out.append(m)
    return out[:6]

def detect_gray_charges(frame, subs):
    """
    Detect 'gray charges' - forgotten free trials that converted to paid services.
    Looks for patterns where:
    1. A merchant appears in subscriptions
    2. There was a $0 or very small initial charge (free trial)
    3. Followed by regular paid charges
    4. Merchant name suggests trial service (common patterns)
    """
    gray_charges = []
    
    # Common free trial merchant name patterns
    trial_keywords = ['trial', 'free', 'promo', 'intro', 'start', 'new', 'signup']
    
    for merchant in subs:
        merchant_df = frame[frame["merchant"] == merchant].sort_values("date")
        if len(merchant_df) < 3:
            continue
        
        amounts = merchant_df["amount"].abs()
        first_amount = amounts.iloc[0]
        subsequent_amounts = amounts.iloc[1:]
        
        # Check if first charge was $0 or very small (free trial indicator)
        is_trial_pattern = (first_amount < 5 and subsequent_amounts.mean() > first_amount * 2)
        
        # Check merchant name for trial keywords
        merchant_lower = merchant.lower()
        has_trial_keyword = any(keyword in merchant_lower for keyword in trial_keywords)
        
        # Check if there's a gap suggesting trial period (often 7, 14, or 30 days)
        if len(merchant_df) > 1:
            first_gap = (merchant_df["date"].iloc[1] - merchant_df["date"].iloc[0]).days
            trial_gap = first_gap in [7, 14, 21, 30, 31]  # Common trial periods
            
            # If it looks like a trial that converted
            if (is_trial_pattern or has_trial_keyword or trial_gap) and first_amount < subsequent_amounts.mean() * 0.5:
                current_monthly = subsequent_amounts.mean()
                gray_charges.append({
                    "merchant": merchant,
                    "first_charge": float(first_amount),
                    "current_monthly": float(current_monthly),
                    "annual_cost": float(current_monthly * 12),
                    "trial_indicator": "Free trial converted" if first_amount < 1 else f"Low intro rate (${first_amount:.2f})"
                })
    
    return gray_charges

def anomalies(g):
    a=g.copy()
    if len(a)<20: return []
    z=(a["amount"].abs()-a["amount"].abs().mean())/(a["amount"].abs().std()+1e-6)
    s=a.loc[(z>2.0)&(a["amount"].abs()>50),["merchant","amount","date"]]
    return s.nsmallest(3,"amount").to_dict(orient="records")



def detect_spending_habits(df_month):
    """Detect frequent small purchases that could be optimized (e.g., daily coffee)"""
    habits = []
    for cat, group in df_month.groupby("category"):
        if cat in ["Coffee", "Dining", "Rideshare"]:
            freq = len(group)
            total = group["amount"].abs().sum()
            avg = group["amount"].abs().mean()
            if freq >= 10 and avg < 20:  # Frequent small purchases
                monthly_total = total
                annual_proj = monthly_total * 12
                habits.append({
                    "category": cat,
                    "frequency": freq,
                    "monthly_total": float(monthly_total),
                    "avg_transaction": float(avg),
                    "annual_projection": float(annual_proj),
                    "savings_potential": float(annual_proj * 0.3)  # Assume 30% savings possible
                })
    return habits

def analyze_spending_patterns(df_month):
    """Analyze spending by day of week and detect patterns"""
    df_month = df_month.copy()
    df_month["day_of_week"] = df_month["date"].dt.day_name()
    df_month["is_weekend"] = df_month["date"].dt.weekday >= 5
    
    weekend_spend = df_month[df_month["is_weekend"] & (df_month["amount"] < 0)]["amount"].abs().sum()
    weekday_spend = df_month[~df_month["is_weekend"] & (df_month["amount"] < 0)]["amount"].abs().sum()
    
    # Fix: apply abs() within the aggregation, not on SeriesGroupBy
    day_patterns = df_month[df_month["amount"] < 0].groupby("day_of_week")["amount"].apply(lambda x: x.abs().sum()).to_dict()
    
    return {
        "weekend_spend": float(weekend_spend),
        "weekday_spend": float(weekday_spend),
        "weekend_ratio": float(weekend_spend / (weekend_spend + weekday_spend + 1e-6)),
        "day_patterns": {k: float(v) for k, v in day_patterns.items()},
        "peak_spending_day": max(day_patterns.items(), key=lambda x: x[1])[0] if day_patterns else None
    }

def calculate_savings_opportunities(df_month, df_all):
    """Identify specific savings opportunities with dollar amounts"""
    opportunities = []
    
    # 1. Subscription analysis
    subs = find_subs(df_all[df_all["date"] <= df_month["date"].max()])
    if subs:
        sub_df = df_all[df_all["merchant"].isin(subs) & (df_all["amount"] < 0)]
        sub_monthly = sub_df["amount"].abs().sum() / max(1, len(sub_df.groupby(sub_df["date"].dt.to_period("M"))))
        opportunities.append({
            "type": "subscriptions",
            "description": f"Review {len(subs)} recurring subscriptions",
            "monthly_cost": float(sub_monthly),
            "annual_cost": float(sub_monthly * 12),
            "potential_savings": float(sub_monthly * 0.2)  # Assume 20% could be cancelled
        })
    
    # 1b. Gray charges (forgotten free trials)
    gray_charges = detect_gray_charges(df_all[df_all["date"] <= df_month["date"].max()], subs)
    if gray_charges:
        total_gray_annual = sum(gc["annual_cost"] for gc in gray_charges)
        opportunities.append({
            "type": "gray_charges",
            "description": f"‚ö†Ô∏è {len(gray_charges)} forgotten free trial(s) converted to paid",
            "monthly_cost": float(total_gray_annual / 12),
            "annual_cost": float(total_gray_annual),
            "potential_savings": float(total_gray_annual * 0.8),  # 80% could be cancelled (forgotten trials)
            "suggestion": "These were likely free trials you forgot to cancel!"
        })
    
    # 2. Habit-based savings (coffee, dining out)
    habits = detect_spending_habits(df_month)
    for habit in habits:
        if habit["category"] == "Coffee":
            opportunities.append({
                "type": "habit_optimization",
                "description": f"Daily {habit['category'].lower()} habit: {habit['frequency']} purchases/month",
                "monthly_cost": habit["monthly_total"],
                "annual_cost": habit["annual_projection"],
                "potential_savings": habit["savings_potential"],
                "suggestion": "Brewing at home could save you over $1,000/year!"
            })
    
    # 3. Category comparison to identify overspending
    cur_cats = month_cat_sums(df_month)
    if len(df_all) > 30:
        prev_month = df_all[df_all["date"] < df_month["date"].min()]
        if len(prev_month) > 0:
            prev_month_periods = prev_month["date"].dt.to_period("M")
            if len(prev_month_periods.unique()) > 0:
                latest_prev_period = prev_month_periods.max()
                prev_month_data = prev_month[prev_month_periods == latest_prev_period]
                if len(prev_month_data) > 0:
                    prev_cats = month_cat_sums(prev_month_data)
                    for cat, cur_val in cur_cats.items():
                        prev_val = prev_cats.get(cat, 0)
                        if prev_val > 0 and cur_val > prev_val * 1.5 and cur_val > 100:
                            opportunities.append({
                                "type": "spending_increase",
                                "description": f"{cat} spending increased {int((cur_val/prev_val - 1)*100)}%",
                                "monthly_cost": float(cur_val - prev_val),
                                "annual_cost": float((cur_val - prev_val) * 12),
                                "potential_savings": float((cur_val - prev_val) * 0.5)
                            })
    
    return opportunities

def track_goal_progress(df_all, goal):
    """Track progress toward user's financial goal"""
    if not goal or goal.get("target", 0) == 0:
        return None
    
    # Calculate cumulative savings
    monthly_net = df_all.groupby(df_all["date"].dt.to_period("M")).apply(
        lambda g: g[g["amount"]>0]["amount"].sum() - g[g["amount"]<0]["amount"].abs().sum()
    )
    
    cumulative_savings = monthly_net.cumsum().iloc[-1] if len(monthly_net) > 0 else 0
    target = goal.get("target", 3000)
    months_elapsed = len(monthly_net)
    months_total = goal.get("months", 10)
    
    if months_total > 0:
        required_monthly = target / months_total
        current_monthly = cumulative_savings / max(months_elapsed, 1)
        on_track = cumulative_savings >= (target * months_elapsed / months_total)
        projected_completion = (target / current_monthly) if current_monthly > 0 else months_total
        
        return {
            "goal_name": goal.get("name", "Savings Goal"),
            "target": float(target),
            "current": float(cumulative_savings),
            "progress_pct": float(min(100, (cumulative_savings / target) * 100)),
            "months_elapsed": int(months_elapsed),
            "months_total": int(months_total),
            "required_monthly": float(required_monthly),
            "current_monthly": float(current_monthly),
            "on_track": on_track,
            "projected_completion_months": float(projected_completion),
            "shortfall": float(max(0, target - cumulative_savings))
        }
    return None

def detect_lifestyle_inflation(df_all):
    """Detect if spending is increasing over time (lifestyle inflation)"""
    if len(df_all) < 60:  # Need at least 2 months
        return None
    
    # Fix: apply abs() within the aggregation, not on SeriesGroupBy
    monthly_spend = df_all[df_all["amount"] < 0].groupby(
        df_all["date"].dt.to_period("M")
    )["amount"].apply(lambda x: x.abs().sum())
    
    if len(monthly_spend) < 3:
        return None
    
    # Calculate trend
    x = np.arange(len(monthly_spend))
    y = monthly_spend.values
    slope = np.polyfit(x, y, 1)[0]
    trend_pct = (slope / monthly_spend.mean()) * 100 if monthly_spend.mean() > 0 else 0
    
    return {
        "trend_percentage": float(trend_pct),
        "is_inflating": trend_pct > 5,  # More than 5% monthly increase
        "first_month": float(monthly_spend.iloc[0]),
        "latest_month": float(monthly_spend.iloc[-1]),
        "change_pct": float(((monthly_spend.iloc[-1] / monthly_spend.iloc[0]) - 1) * 100) if monthly_spend.iloc[0] > 0 else 0
    }

def calculate_emergency_fund_recommendation(df_all):
    """Recommend emergency fund based on monthly expenses"""
    monthly_expenses = df_all[df_all["amount"] < 0]["amount"].abs().sum() / max(1, len(df_all["date"].dt.to_period("M").unique()))
    recommended_3mo = monthly_expenses * 3
    recommended_6mo = monthly_expenses * 6
    
    return {
        "monthly_expenses": float(monthly_expenses),
        "recommended_3mo": float(recommended_3mo),
        "recommended_6mo": float(recommended_6mo),
        "current_savings_rate": None  # Would need savings account data
    }

def check_budget_vs_actual(df_month, budgets):
    """Compare actual spending vs budgeted amounts by category"""
    if not budgets:
        return {}
    
    actual = month_cat_sums(df_month)
    budget_status = {}
    
    for category, budget_amount in budgets.items():
        actual_amount = actual.get(category, 0)
        if budget_amount > 0:
            percentage = (actual_amount / budget_amount) * 100
            status = "under" if percentage < 90 else "warning" if percentage < 110 else "over"
            budget_status[category] = {
                "budget": float(budget_amount),
                "actual": float(actual_amount),
                "remaining": float(budget_amount - actual_amount),
                "percentage": float(percentage),
                "status": status
            }
    
    return budget_status

def create_budget_chart(budget_status):
    """Create bar chart comparing budget vs actual spending"""
    if not budget_status:
        return None
    
    categories = list(budget_status.keys())
    budgets = [budget_status[cat]["budget"] for cat in categories]
    actuals = [budget_status[cat]["actual"] for cat in categories]
    
    fig = go.Figure()
    fig.add_trace(go.Bar(
        x=categories,
        y=budgets,
        name='Budget',
        marker_color='#3498DB',
        text=[f'${b:.0f}' for b in budgets],
        textposition='auto',
    ))
    fig.add_trace(go.Bar(
        x=categories,
        y=actuals,
        name='Actual',
        marker_color=['#27AE60' if budget_status[cat]["status"] == "under" 
                     else '#F39C12' if budget_status[cat]["status"] == "warning" 
                     else '#E74C3C' for cat in categories],
        text=[f'${a:.0f}' for a in actuals],
        textposition='auto',
    ))
    
    fig.update_layout(
        title="Budget vs Actual Spending",
        xaxis_title="Category",
        yaxis_title="Amount ($)",
        barmode='group',
        hovermode='x unified',
        height=400
    )
    return fig

def build_summary(month, df_all, custom_goal=None, budgets=None):
    cur = df_all[df_all["month"]==month]
    prev = df_all[df_all["month"]==(month-pd.offsets.MonthBegin(1))]
    cur_sum = {
        "total_spend": float(-cur[cur["amount"]<0]["amount"].sum()),
        "total_income": float(cur[cur["amount"]>0]["amount"].sum()),
        "by_category": month_cat_sums(cur)
    }
    prev_sum = {"by_category": month_cat_sums(prev)} if len(prev) else {"by_category": {}}
    subs = find_subs(df_all[df_all["date"]<=month])
    gray_charges = detect_gray_charges(df_all[df_all["date"]<=month], subs)
    anom = anomalies(cur)
    recent = (df_all.groupby("month").agg(spend=("amount",lambda s:-s[s<0].sum()),
                                          income=("amount",lambda s:s[s>0].sum()))
              .loc[:month].pipe(lambda t:(t["income"]-t["spend"]).tail(3).mean()))
    proj = float(0 if np.isnan(recent) else recent)
    
    # Use custom goal or default
    goal = custom_goal if custom_goal else {"name":"Save $3k in 10 months","target":3000,"months":10}
    
    habits = detect_spending_habits(cur)
    patterns = analyze_spending_patterns(cur)
    opportunities = calculate_savings_opportunities(cur, df_all)
    goal_progress = track_goal_progress(df_all[df_all["date"]<=month], goal)
    inflation = detect_lifestyle_inflation(df_all[df_all["date"]<=month])
    emergency_fund = calculate_emergency_fund_recommendation(df_all[df_all["date"]<=month])
    
    # Budget tracking
    budget_status = check_budget_vs_actual(cur, budgets) if budgets else {}
    
    return {
        "period": str(pd.Timestamp(month).date()),
        "this_month": cur_sum, "prev_month": prev_sum,
        "subscriptions": subs, "gray_charges": gray_charges, "anomalies": anom,
        "projection": proj,
        "user_goal": goal,
        "budgets": budgets,
        "budget_status": budget_status,
        # Behavioral insights
        "spending_habits": habits,
        "spending_patterns": patterns,
        "savings_opportunities": opportunities,
        "goal_progress": goal_progress,
        "lifestyle_inflation": inflation,
        "emergency_fund": emergency_fund
    }

def target_text(summary):
    cur, prev = summary["this_month"], summary["prev_month"]
    txt=[]
    for cat, cval in list(cur.get("by_category",{}).items())[:5]:
        pval = prev.get("by_category",{}).get(cat,0)
        if pval>0 and cval>pval*1.3 and cval>40:
            txt.append(f"{cat} up {int((cval-pval)/pval*100)}% MoM (${cval:.0f} vs ${pval:.0f}). Consider a weekly cap.")
    if summary["subscriptions"]:
        txt.append("Recurring charges detected: " + ", ".join(summary["subscriptions"][:4]) + ". Review unused.")
    if summary.get("gray_charges"):
        gc = summary["gray_charges"]
        gc_names = [g["merchant"] for g in gc[:3]]
        total_annual = sum(g["annual_cost"] for g in gc)
        txt.append(f"‚ö†Ô∏è Gray charges: {len(gc)} forgotten free trial(s) ({', '.join(gc_names)}) costing ${total_annual:.0f}/yr. Cancel if unused!")
    if summary["anomalies"]:
        ex = "; ".join([f'{r["merchant"]} ${abs(r["amount"]):.0f} on {pd.to_datetime(r["date"]).date()}' for r in summary["anomalies"]])
        txt.append(f"Unusual purchases: {ex}. Verify.")
    txt.append(f"Projected next-month savings ‚âà ${summary['projection']:.0f} based on recent average.")
    return "\n".join(txt[:5]) or "Spending stable. Keep up the good habits."

def format_ai_insights(insights_text):
    """
    Format AI insights with visual styling, icons, and better structure
    """
    if not insights_text or len(insights_text.strip()) == 0:
        return "### üí° No insights available at this time."
    
    # Split insights by newlines or bullet points
    lines = insights_text.replace('\n- ', '\n').replace('- ', '').split('\n')
    lines = [line.strip() for line in lines if line.strip()]
    
    formatted_insights = []
    
    for i, line in enumerate(lines, 1):
        # Determine icon and color based on content
        icon = "üìä"
        color = "#4A90E2"  # Default blue
        
        if "up" in line.lower() or "increase" in line.lower() or "%" in line:
            icon = "üìà"
            color = "#E74C3C"  # Red for increases
        elif "down" in line.lower() or "decrease" in line.lower():
            icon = "üìâ"
            color = "#27AE60"  # Green for decreases
        elif "recurring" in line.lower() or "subscription" in line.lower() or "charges" in line.lower():
            icon = "üîî"
            color = "#F39C12"  # Orange for subscriptions
        elif "gray" in line.lower() or "trial" in line.lower():
            icon = "‚ö†Ô∏è"
            color = "#E67E22"  # Dark orange for gray charges
        elif "unusual" in line.lower() or "anomal" in line.lower() or "verify" in line.lower():
            icon = "üîç"
            color = "#9B59B6"  # Purple for anomalies
        elif "savings" in line.lower() or "save" in line.lower() or "projected" in line.lower():
            icon = "üí∞"
            color = "#27AE60"  # Green for savings
        elif "cap" in line.lower() or "consider" in line.lower() or "review" in line.lower():
            icon = "üí°"
            color = "#3498DB"  # Blue for suggestions
        
        # Extract dollar amounts and make them bold
        import re
        line_formatted = re.sub(r'\$([\d,]+\.?\d*)', r'**$\1**', line)
        
        # Convert hex to rgba for background
        def hex_to_rgba(hex_color, alpha=0.1):
            hex_color = hex_color.lstrip('#')
            r = int(hex_color[0:2], 16)
            g = int(hex_color[2:4], 16)
            b = int(hex_color[4:6], 16)
            return f"rgba({r}, {g}, {b}, {alpha})"
        
        bg_color_light = hex_to_rgba(color, 0.08)
        bg_color_lighter = hex_to_rgba(color, 0.03)
        
        # Create styled insight card
        insight_card = f"""
<div style="
    background: linear-gradient(135deg, {bg_color_light} 0%, {bg_color_lighter} 100%);
    border-left: 4px solid {color};
    padding: 18px 20px;
    margin: 16px 0;
    border-radius: 10px;
    box-shadow: 0 3px 6px rgba(0,0,0,0.08);
    transition: transform 0.2s, box-shadow 0.2s;
">
<div style="display: flex; align-items: center; margin-bottom: 10px;">
    <span style="font-size: 28px; margin-right: 14px; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1));">{icon}</span>
    <span style="font-weight: 700; color: {color}; font-size: 17px; letter-spacing: 0.3px;">Insight #{i}</span>
</div>
<div style="color: #2C3E50; line-height: 1.7; font-size: 15.5px; font-weight: 400;">
{line_formatted}
</div>
</div>
"""
        formatted_insights.append(insight_card)
    
    # Combine all insights with styled header
    header = """
<div style="
    text-align: center; 
    margin-bottom: 32px; 
    padding: 24px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
">
    <h2 style="color: #FFFFFF; margin: 0 0 8px 0; font-size: 28px; font-weight: 700; text-shadow: 0 2px 4px rgba(0,0,0,0.2);">
        ü§ñ AI-Generated Insights
    </h2>
    <p style="color: rgba(255,255,255,0.95); margin: 0; font-size: 15px; font-weight: 400;">
        Personalized financial recommendations based on your spending patterns
    </p>
</div>
"""
    
    return header + "\n".join(formatted_insights)



def safe_dumps(o):
    """JSON-serialize dicts/lists with pandas.Timestamp / datetime / NumPy types."""
    def _conv(x):
        if hasattr(x, "isoformat"):      # pandas.Timestamp / datetime
            return str(x)
        if isinstance(x, (np.floating, np.integer)):
            return float(x)
        return str(x)
    return json.dumps(o, default=_conv)



print("\n" + "="*60)
print("Building training dataset...")
print("="*60)
examples=[]
months = sorted(df["month"].unique())
for m in months:
    summ = build_summary(m, df)
    prompt = (
        "You are a smart financial coach. Given the monthly transaction summary JSON, "
        "write 3‚Äì5 concise, neutral insights with dollar amounts and actionable tips.\n\n"
        f"JSON:\n{safe_dumps(summ)}\n\nInsights:"
    )
    target = target_text(summ)
    examples.append({"input_text": prompt, "labels": target})

ds = Dataset.from_list(examples).train_test_split(test_size=0.2, seed=42)


TRAIN_MODEL = False  # Change to True for full training

print("\n" + "="*60)
print("STEP 1: Loading pre-trained model...")
print("="*60)
model_name = "google/flan-t5-small"
print(f"Downloading {model_name} (this may take a minute on first run)...")
tok = T5TokenizerFast.from_pretrained(model_name)
print("Downloading model weights...")
model = T5ForConditionalGeneration.from_pretrained(model_name)
print("‚úÖ Model loaded successfully!")

# tokenize
from transformers import DataCollatorForSeq2Seq

def preprocess(batch):
    enc = tok(batch["input_text"], max_length=768, truncation=True)
    dec = tok(text_target=batch["labels"], max_length=256, truncation=True)
    enc["labels"] = dec["input_ids"]
    return enc

print("\n" + "="*60)
print("STEP 2: Preparing training data...")
print("="*60)
tokenized_train = ds["train"].map(preprocess, batched=True, remove_columns=["input_text","labels"])
tokenized_eval  = ds["test"].map(preprocess, batched=True, remove_columns=["input_text","labels"])
print("‚úÖ Data prepared!")

if TRAIN_MODEL:
    print("\n" + "="*60)
    print("STEP 3: Training model (this takes 5-10 minutes)...")
    print("="*60)
    args = TrainingArguments(
        output_dir="fincoach-flan-small",
        per_device_train_batch_size=4,
        per_device_eval_batch_size=4,
        learning_rate=3e-4,
        num_train_epochs=2,            # quick
        weight_decay=0.0,
        logging_steps=10,
        evaluation_strategy="epoch",
        save_strategy="no",
        report_to="none"
    )

    data_collator = DataCollatorForSeq2Seq(tokenizer=tok, model=model, padding="longest")

    trainer = Trainer(
        model=model,
        args=args,
        train_dataset=tokenized_train,
        eval_dataset=tokenized_eval,
        tokenizer=tok,
        data_collator=data_collator,
    )
    print("Training started... (you'll see progress updates)")
    trainer.train()
    print("‚úÖ Training complete!")
else:
    print("\n" + "="*60)
    print("STEP 3: Skipping training (QUICK DEMO MODE)")
    print("Using base model without fine-tuning...")
    print("(Set TRAIN_MODEL = True for full fine-tuning)")
    print("="*60)


# ---------------------------------------
# 5) Inference: latest month insights
# ---------------------------------------
print("\n" + "="*60)
print("STEP 4: Generating test insights...")
print("="*60)
import torch, json

def safe_dumps_min(o):
    def _conv(x):
        if hasattr(x, "isoformat"): return str(x)
        if isinstance(x, (np.floating, np.integer)): return float(x)
        return str(x)
    # compact JSON to shorten tokens
    return json.dumps(o, default=_conv, separators=(",", ":"))

# Build JSON summary
latest = df["month"].max()
summ_latest = build_summary(latest, df)

# Compose prompt (compact JSON to reduce length)
test_prompt = (
    "You are a smart financial coach. Given the monthly transaction summary JSON, "
    "write 3‚Äì5 concise, neutral insights with dollar amounts and actionable tips.\n\n"
    f"JSON:\n{safe_dumps_min(summ_latest)}\n\nInsights:"
)

# Put model on a single device and move inputs there; truncate to model max length (512 for T5-small)
device = "cuda" if torch.cuda.is_available() else "cpu"
model.to(device)

inputs = tok(
    test_prompt,
    return_tensors="pt",
    max_length=512,        # <= T5-small limit
    truncation=True
).to(device)

# Test insights - use rule-based when model not trained
if TRAIN_MODEL:
    try:
        with torch.no_grad():
            out = model.generate(
                **inputs,
                max_new_tokens=220,
                do_sample=True,
                temperature=0.7,
                top_p=0.9
            )
        
        test_output = tok.decode(out[0], skip_special_tokens=True)
        # Better validation: check for financial terms and dollar signs
        has_dollar = '$' in test_output
        has_financial_terms = any(term in test_output.lower() for term in ['spend', 'save', 'income', 'month', 'year', 'category', 'subscription'])
        is_valid = len(test_output) > 50 and has_dollar and has_financial_terms
        
        if is_valid:
            print("\n=== TEST INSIGHTS (from fine-tuned model) ===")
            print(test_output)
        else:
            print("\n=== TEST INSIGHTS (using rule-based - model output invalid) ===")
            print(target_text(summ_latest))
    except Exception as e:
        print("\n=== TEST INSIGHTS (using rule-based - model error) ===")
        print(target_text(summ_latest))
else:
    print("\n=== TEST INSIGHTS (using rule-based - quick demo mode) ===")
    print(target_text(summ_latest))
print("\n" + "="*60)
print("STEP 5: Launching web UI...")
print("="*60)
print("The UI will open in your browser shortly...")
print("="*60 + "\n")



# For Colab, uncomment the line below:
# !pip -q install gradio==4.44.0 matplotlib plotly

import gradio as gr, pandas as pd, torch, json, numpy as np
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# --- helpers reused from your notebook ---
def safe_dumps_min(o):
    def _conv(x):
        if hasattr(x, "isoformat"): return str(x)
        if isinstance(x, (np.floating, np.integer)): return float(x)
        return str(x)
    return json.dumps(o, default=_conv, separators=(",", ":"))

def kpis_from_summary(S):
    s=S["this_month"]; return {
        "Total income": f"${s['total_income']:.0f}",
        "Total spend": f"${s['total_spend']:.0f}",
        "Net": f"${(s['total_income']-s['total_spend']):.0f}"
    }

def make_realistic_transactions(months=6):
    """Generate synthetic transaction data (reuse from earlier in notebook)"""
    rng = np.random.default_rng(42)
    start = (pd.Timestamp.today().normalize().to_period("M")-months).to_timestamp()
    dates = pd.date_range(start, periods=months*30, freq="D")
    
    def add_row(rows, d, amt, merch, desc, cat):
        rows.append([d, float(amt), merch, desc, cat])
    
    rows=[]
    for d in dates:
        if d.weekday()==4 and (d.day % 14 in (0,1,2,3)):
            add_row(rows, d, 2200.00, "ACME Payroll", "Biweekly paycheck", "Income")
        if rng.random()<0.06 and d.weekday()<5:
            add_row(rows, d, rng.normal(400,120), "Freelance Payment", "Freelance job", "Income")
    
    for d in dates[::30]:
        add_row(rows, d, -1800.00, "Landlord LLC", "Monthly rent", "Rent")
    for d in dates[14::30]:
        add_row(rows, d, -140.00, "PG&E", "Electricity & Gas", "Utilities")
    for d in dates[6::30]:
        add_row(rows, d, -10.99, "Spotify", "Music subscription", "Subscription")
        add_row(rows, d, -15.49, "Netflix", "Streaming subscription", "Subscription")
        add_row(rows, d, -2.99, "iCloud Storage", "Storage plan", "Subscription")
    
    gro = ["Trader Joe's","Whole Foods","Safeway"]
    cof = ["Starbucks","Peet's Coffee"]
    din = ["Chipotle","Sweetgreen","Shake Shack","Local Diner"]
    tra = ["Caltrain","BART","Gas Station"]
    rid = ["Uber","Lyft"]
    shp = ["Target","Walmart","Amazon"]
    
    for d in dates:
        add_row(rows, d, -abs(rng.normal(35,18)), rng.choice(gro), "Groceries & staples", "Groceries")
        if rng.random()<0.6:  add_row(rows, d, -abs(rng.normal(5.5,2)), rng.choice(cof), "Coffee", "Coffee")
        if rng.random()<0.3:  add_row(rows, d, -abs(rng.normal(18,8)), rng.choice(din), "Meal out", "Dining")
        if rng.random()<0.2:  add_row(rows, d, -abs(rng.normal(7,3)), rng.choice(tra), "Commute", "Transport")
        if rng.random()<0.1:  add_row(rows, d, -abs(rng.normal(22,9)), rng.choice(rid), "Ride", "Rideshare")
        if rng.random()<0.12: add_row(rows, d, -abs(rng.normal(40,25)), rng.choice(shp), "Household items", "Shopping")
    
    df = pd.DataFrame(rows, columns=["date","amount","merchant","description","category"])
    df["date"] = pd.to_datetime(df["date"])
    df = df.sort_values("date").reset_index(drop=True)
    df["month"] = df["date"].dt.to_period("M").dt.to_timestamp()
    return df

device = "cuda" if torch.cuda.is_available() else "cpu"
model.to(device)

def create_category_chart(S):
    """Create pie chart for spending by category"""
    cats = S["this_month"]["by_category"]
    if not cats:
        return None
    df_cats = pd.DataFrame(list(cats.items()), columns=["Category", "Amount"])
    fig = px.pie(df_cats, values="Amount", names="Category", 
                 title="Spending by Category", 
                 color_discrete_sequence=px.colors.qualitative.Set3)
    fig.update_traces(textposition='inside', textinfo='percent+label')
    return fig

def create_trend_chart(df_all):
    """Create line chart showing income vs spending over time"""
    monthly = df_all.groupby(df_all["date"].dt.to_period("M")).agg(
        income=("amount", lambda s: s[s>0].sum()),
        spending=("amount", lambda s: -s[s<0].sum())
    ).reset_index()
    monthly["period"] = monthly["date"].astype(str)
    
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=monthly["period"], y=monthly["income"], 
                            name="Income", line=dict(color="green", width=3)))
    fig.add_trace(go.Scatter(x=monthly["period"], y=monthly["spending"], 
                            name="Spending", line=dict(color="red", width=3)))
    fig.update_layout(title="Income vs Spending Trend", xaxis_title="Month", 
                     yaxis_title="Amount ($)", hovermode='x unified')
    return fig

def create_goal_progress_chart(goal_progress):
    """Create progress bar for goal tracking"""
    if not goal_progress:
        return None
    fig = go.Figure(go.Indicator(
        mode = "gauge+number+delta",
        value = goal_progress["current"],
        domain = {'x': [0, 1], 'y': [0, 1]},
        title = {'text': goal_progress["goal_name"]},
        delta = {'reference': goal_progress["target"]},
        gauge = {
            'axis': {'range': [None, goal_progress["target"]]},
            'bar': {'color': "green" if goal_progress["on_track"] else "orange"},
            'steps': [
                {'range': [0, goal_progress["target"]*0.5], 'color': "lightgray"},
                {'range': [goal_progress["target"]*0.5, goal_progress["target"]*0.8], 'color': "gray"}
            ],
            'threshold': {
                'line': {'color': "red", 'width': 4},
                'thickness': 0.75,
                'value': goal_progress["target"]
            }
        }
    ))
    fig.update_layout(height=300)
    return fig

def format_behavioral_insights(S):
    """Format behavioral insights into readable text"""
    insights = []
    
    # Spending habits
    if S.get("spending_habits"):
        for habit in S["spending_habits"]:
            insights.append(f"‚òï **{habit['category']} Habit**: {habit['frequency']} purchases/month "
                          f"(${habit['monthly_total']:.0f}/mo, ${habit['annual_projection']:.0f}/yr). "
                          f"Potential savings: ${habit['savings_potential']:.0f}/year")
    
    # Spending patterns
    if S.get("spending_patterns"):
        pat = S["spending_patterns"]
        if pat.get("peak_spending_day"):
            insights.append(f"üìÖ **Peak Spending Day**: {pat['peak_spending_day']} "
                          f"({pat['weekend_ratio']*100:.0f}% of spending on weekends)")
    
    # Gray charges (forgotten free trials)
    if S.get("gray_charges"):
        gc = S["gray_charges"]
        total_gray_annual = sum(g["annual_cost"] for g in gc)
        insights.append(f"‚ö†Ô∏è **Gray Charges Detected**: {len(gc)} forgotten free trial(s) converted to paid "
                      f"(${total_gray_annual:.0f}/year). Review and cancel unused services!")
        for g in gc[:3]:
            insights.append(f"  ‚Ä¢ {g['merchant']}: {g['trial_indicator']} ‚Üí Now ${g['current_monthly']:.2f}/mo")
    
    # Savings opportunities
    if S.get("savings_opportunities"):
        total_potential = sum(opp.get("potential_savings", 0) for opp in S["savings_opportunities"])
        insights.append(f"üí∞ **Total Savings Potential**: ${total_potential:.0f}/year identified")
        for opp in S["savings_opportunities"][:3]:
            insights.append(f"  ‚Ä¢ {opp.get('description', '')}: ${opp.get('annual_cost', 0):.0f}/yr ‚Üí "
                          f"Save ${opp.get('potential_savings', 0):.0f}/yr")
    
    # Goal progress
    if S.get("goal_progress"):
        gp = S["goal_progress"]
        status = "‚úÖ On track" if gp["on_track"] else "‚ö†Ô∏è Behind schedule"
        insights.append(f"üéØ **Goal Progress**: {gp['progress_pct']:.0f}% complete "
                      f"(${gp['current']:.0f}/${gp['target']:.0f}) - {status}")
        if not gp["on_track"]:
            insights.append(f"   Need to save ${gp['shortfall']:.0f} more to reach goal")
    
    # Lifestyle inflation
    if S.get("lifestyle_inflation") and S["lifestyle_inflation"].get("is_inflating"):
        inf = S["lifestyle_inflation"]
        insights.append(f"üìà **Lifestyle Inflation Detected**: Spending increased "
                      f"{inf['change_pct']:.1f}% over time. Consider reviewing expenses.")
    
    # Emergency fund
    if S.get("emergency_fund"):
        ef = S["emergency_fund"]
        insights.append(f"üõ°Ô∏è **Emergency Fund Recommendation**: "
                      f"${ef['recommended_3mo']:.0f} (3 months) or ${ef['recommended_6mo']:.0f} (6 months)")
    
    # Budget status
    if S.get("budget_status"):
        budget_status = S["budget_status"]
        over_budget = [cat for cat, status in budget_status.items() if status["status"] == "over"]
        under_budget = [cat for cat, status in budget_status.items() if status["status"] == "under"]
        
        if over_budget:
            insights.append(f"üî¥ **Over Budget**: {', '.join(over_budget)} - Review spending in these categories")
        if under_budget:
            insights.append(f"‚úÖ **Under Budget**: {', '.join(under_budget)} - Great job staying within limits!")
        
        # Show budget details with above/below indicators
        for cat, status in list(budget_status.items())[:3]:
            status_icon = "‚úÖ" if status["status"] == "under" else "‚ö†Ô∏è" if status["status"] == "warning" else "üî¥"
            difference = status['actual'] - status['budget']
            if difference > 0:
                diff_text = f"${abs(difference):.0f} OVER budget"
            elif difference < 0:
                diff_text = f"${abs(difference):.0f} UNDER budget"
            else:
                diff_text = "ON BUDGET"
            insights.append(f"  ‚Ä¢ {cat}: {status_icon} ${status['actual']:.0f} / ${status['budget']:.0f} "
                          f"({status['percentage']:.0f}%) - {diff_text}")
    
    return "\n\n".join(insights) if insights else "No additional behavioral insights available."

def get_top_categories(df, exclude_categories=["Rent", "Income"], top_n=5):
    """Get top N spending categories excluding specified ones"""
    # Get latest month's spending by category
    latest_month = df["month"].max()
    latest_data = df[df["month"] == latest_month]
    
    # Calculate spending by category (negative amounts are expenses)
    cat_spending = latest_data[latest_data["amount"] < 0].groupby("category")["amount"].sum().abs()
    
    # Exclude specified categories
    for cat in exclude_categories:
        if cat in cat_spending.index:
            cat_spending = cat_spending.drop(cat)
    
    # Get top N
    top_cats = cat_spending.nlargest(top_n).index.tolist()
    return top_cats

def run_pipeline(file, goal_name, goal_amount, goal_months, 
                 budget_cat1, budget_cat2, budget_cat3, budget_cat4, budget_cat5):
    try:
        # 1) Data - CSV required (synthetic data removed)
        if file is None:
            return ("‚ö†Ô∏è Please upload a CSV file", "", "", 
                   "CSV file is required. Please upload a file with columns: date, amount, merchant, description, category",
                   "", None, None, None, None,
                   pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), "",
                   gr.update(), gr.update(), gr.update(), gr.update(), gr.update())
        
        try:
            df = pd.read_csv(file.name)
            df["date"] = pd.to_datetime(df["date"])
            if "month" not in df.columns:
                df["month"] = df["date"].dt.to_period("M").dt.to_timestamp()
        except Exception as e:
            return (f"Error reading CSV: {str(e)}", "", "", 
                   "Please check your CSV format. Required columns: date, amount, merchant, description, category",
                   "", None, None, None, None,
                   pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), "",
                   gr.update(), gr.update(), gr.update(), gr.update(), gr.update())

        # 2) Get top 5 categories (excluding rent) for budget tracking
        top_categories = get_top_categories(df, exclude_categories=["Rent", "Income"], top_n=5)
        
        # 3) Build budgets dictionary from individual inputs
        budgets = {}
        budget_inputs = [budget_cat1, budget_cat2, budget_cat3, budget_cat4, budget_cat5]
        for i, category in enumerate(top_categories[:5]):
            if i < len(budget_inputs) and budget_inputs[i] and budget_inputs[i] > 0:
                budgets[category] = float(budget_inputs[i])

        # 4) Build custom goal
        custom_goal = None
        if goal_amount and goal_amount > 0 and goal_months and goal_months > 0:
            custom_goal = {
                "name": goal_name if goal_name else f"Save ${goal_amount:.0f}",
                "target": float(goal_amount),
                "months": int(goal_months)
            }

        # 5) Latest month summary
        latest = df["month"].max()
        S = build_summary(latest, df, custom_goal=custom_goal, budgets=budgets if budgets else None)
    except Exception as e:
        error_msg = f"Error processing data: {str(e)}"
        return (error_msg, "", "", error_msg, "", None, None, None,
               pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), "",
               gr.update(), gr.update(), gr.update(), gr.update(), gr.update())
    
    try:
        # 3) Generate AI insights (use rule-based if model not trained)
        if TRAIN_MODEL:
            try:
                prompt = (
                    "You are a smart financial coach. Given the monthly transaction summary JSON, "
                    "write 4‚Äì5 concise, neutral insights with dollar amounts and clear actions. "
                    "Do not hallucinate numbers not present in JSON.\n\n"
                    f"JSON:\n{safe_dumps_min(S)}\n\nInsights:\n- "
                )
                inputs = tok(prompt, return_tensors="pt", max_length=512, truncation=True).to(device)
                with torch.no_grad():
                    out = model.generate(**inputs, max_new_tokens=220, do_sample=True, temperature=0.7, top_p=0.9)
                raw_insights = tok.decode(out[0], skip_special_tokens=True).split("Insights:")[-1].strip()
                
                # Better validation: check for financial terms and dollar signs
                has_dollar = '$' in raw_insights
                has_financial_terms = any(term in raw_insights.lower() for term in ['spend', 'save', 'income', 'month', 'year', 'category', 'subscription'])
                is_valid = len(raw_insights) > 50 and has_dollar and has_financial_terms
                
                if is_valid:
                    raw_insights_text = raw_insights
                else:
                    # Fallback to rule-based insights
                    raw_insights_text = target_text(S)
            except Exception as e:
                # Fallback to rule-based insights on error
                raw_insights_text = target_text(S)
        else:
            # Use rule-based insights when model isn't trained
            raw_insights_text = target_text(S)
        
        # Format insights with visual styling
        ai_insights = format_ai_insights(raw_insights_text)

        # 4) Format behavioral insights
        behavioral_insights = format_behavioral_insights(S)

        # 5) Create visualizations
        cat_chart = create_category_chart(S)
        trend_chart = create_trend_chart(df)
        goal_chart = create_goal_progress_chart(S.get("goal_progress"))

        # 6) Format budget status for display with above/below indicators
        budget_table = None
        if S.get("budget_status"):
            budget_data = []
            for cat, status in S["budget_status"].items():
                status_icon = "‚úÖ" if status["status"] == "under" else "‚ö†Ô∏è" if status["status"] == "warning" else "üî¥"
                # Calculate how far above/below budget
                difference = status['actual'] - status['budget']
                if difference > 0:
                    diff_text = f"${abs(difference):.2f} OVER"
                    diff_color = "üî¥"
                elif difference < 0:
                    diff_text = f"${abs(difference):.2f} UNDER"
                    diff_color = "‚úÖ"
                else:
                    diff_text = "ON BUDGET"
                    diff_color = "‚úÖ"
                
                budget_data.append({
                    "Category": cat,
                    "Budget": f"${status['budget']:.2f}",
                    "Actual": f"${status['actual']:.2f}",
                    "Difference": f"{diff_color} {diff_text}",
                    "Status": f"{status_icon} {status['percentage']:.1f}%"
                })
            budget_table = pd.DataFrame(budget_data)
        else:
            budget_table = pd.DataFrame(columns=["Category", "Budget", "Actual", "Difference", "Status"])

        # 7) Presentable tables
        subs = pd.DataFrame({"subscription": S["subscriptions"]}) if S["subscriptions"] else pd.DataFrame({"subscription":[]})
        anom = pd.DataFrame(S["anomalies"]) if S["anomalies"] else pd.DataFrame(columns=["merchant","amount","date"])
        topcats = pd.DataFrame(
            sorted(S["this_month"]["by_category"].items(), key=lambda x:-x[1])[:6],
            columns=["category","amount"]
        )
        
        # Gray charges table
        if S.get("gray_charges"):
            gray_df = pd.DataFrame(S["gray_charges"])
            gray_df = gray_df[["merchant", "trial_indicator", "current_monthly", "annual_cost"]]
            gray_df.columns = ["Merchant", "Trial Info", "Monthly Cost", "Annual Cost"]
        else:
            gray_df = pd.DataFrame(columns=["Merchant", "Trial Info", "Monthly Cost", "Annual Cost"])
        
        # Savings opportunities table
        if S.get("savings_opportunities"):
            opp_df = pd.DataFrame(S["savings_opportunities"])
            opp_df = opp_df[["description", "annual_cost", "potential_savings"]]
            opp_df.columns = ["Opportunity", "Annual Cost", "Potential Savings"]
        else:
            opp_df = pd.DataFrame(columns=["Opportunity", "Annual Cost", "Potential Savings"])

        # KPIs
        kpi = kpis_from_summary(S)
        
        # Format top categories for display with budget inputs
        top_cats_markdown = f"**Your Top 5 Spending Categories** (excluding Rent):\n\n"
        category_labels = []
        if top_categories:
            latest_month = df["month"].max()
            latest_data = df[df["month"] == latest_month]
            for i, cat in enumerate(top_categories, 1):
                # Get spending amount for this category
                cat_spending = latest_data[(latest_data["category"] == cat) & (latest_data["amount"] < 0)]["amount"].sum()
                top_cats_markdown += f"{i}. **{cat}**: ${abs(cat_spending):.2f} (this month)\n"
                category_labels.append(cat)
            
            # Add note about which input corresponds to which category
            if len(category_labels) > 0:
                top_cats_markdown += f"\nüí° *Enter your budgets in the fields above. The labels will update to show the category names after you generate insights.*"
        else:
            top_cats_markdown = "**Top Categories:** Upload CSV and generate insights to see your top spending categories"
        
        # Update budget input labels with actual category names
        budget_label_updates = []
        for i, cat in enumerate(category_labels[:5], 1):
            budget_label_updates.append(f"{cat} Budget ($/month)")
        
        return (kpi["Total income"], kpi["Total spend"], kpi["Net"], 
                ai_insights, behavioral_insights,
                cat_chart, trend_chart, goal_chart,
                subs, gray_df, anom, topcats, opp_df, budget_table, top_cats_markdown,
                gr.update(label=budget_label_updates[0] if len(budget_label_updates) > 0 else "Budget ($/month)"),
                gr.update(label=budget_label_updates[1] if len(budget_label_updates) > 1 else "Budget ($/month)"),
                gr.update(label=budget_label_updates[2] if len(budget_label_updates) > 2 else "Budget ($/month)"),
                gr.update(label=budget_label_updates[3] if len(budget_label_updates) > 3 else "Budget ($/month)"),
                gr.update(label=budget_label_updates[4] if len(budget_label_updates) > 4 else "Budget ($/month)"))
    except Exception as e:
        error_msg = f"Error generating insights: {str(e)}"
        import traceback
        traceback.print_exc()
        return (error_msg, "", "", error_msg, "", None, None, None,
               pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), pd.DataFrame(), "",
               gr.update(), gr.update(), gr.update(), gr.update(), gr.update())

with gr.Blocks(title="Smart Financial Coach", theme=gr.themes.Soft()) as demo:
    # Header with gradient styling
    gr.Markdown("""
    <div style="
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 30px;
        border-radius: 12px;
        margin-bottom: 24px;
        text-align: center;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    ">
        <h1 style="color: #FFFFFF; margin: 0; font-size: 36px; font-weight: 700; text-shadow: 0 2px 4px rgba(0,0,0,0.2);">
            üí∞ Smart Financial Coach
        </h1>
        <p style="color: rgba(255,255,255,0.95); margin: 12px 0 0 0; font-size: 18px;">
            AI-Powered Personal Finance Insights & Behavioral Analysis
        </p>
    </div>
    """)
    
    # Input Section - Organized in tabs
    with gr.Tabs() as input_tabs:
        with gr.Tab("üìÅ Upload Data"):
            gr.Markdown("""
            ### Upload Your Transaction Data
            Upload a CSV file with your financial transactions.
            """)
            file = gr.File(label="üìÑ CSV File", file_types=[".csv"])
        
        with gr.Tab("üéØ Set Goals"):
            gr.Markdown("""
            ### Set Your Financial Goal
            Define a savings or spending goal to track your progress.
            """)
            with gr.Row():
                goal_name = gr.Textbox(label="Goal Name", value="Emergency Fund", 
                                     placeholder="e.g., Emergency Fund, Vacation, Down Payment")
                goal_amount = gr.Number(label="Target Amount ($)", value=3000, minimum=0)
                goal_months = gr.Number(label="Timeline (months)", value=10, minimum=1, 
                                       maximum=120, step=1)
        
        with gr.Tab("üí∞ Set Budgets"):
            gr.Markdown("""
            ### Set Monthly Budgets by Category
            
            **Dynamic Budget Categories**: After you upload your CSV and generate insights, your **top 5 spending categories** (excluding Rent) will be automatically identified. Enter your monthly budget for each category below.
            
            The app will show you how far above or below your budget you are for the current month.
            """)
            top_categories_display = gr.Markdown("**Top Categories:** Upload CSV and generate insights to see your top spending categories")
            
            with gr.Row():
                with gr.Column():
                    budget_cat1 = gr.Number(label="Budget ($/month)", value=0, minimum=0, 
                                          info="Will show your top spending category after analysis")
                    budget_cat2 = gr.Number(label="Budget ($/month)", value=0, minimum=0,
                                          info="Will show your 2nd top spending category after analysis")
                    budget_cat3 = gr.Number(label="Budget ($/month)", value=0, minimum=0,
                                          info="Will show your 3rd top spending category after analysis")
                with gr.Column():
                    budget_cat4 = gr.Number(label="Budget ($/month)", value=0, minimum=0,
                                          info="Will show your 4th top spending category after analysis")
                    budget_cat5 = gr.Number(label="Budget ($/month)", value=0, minimum=0,
                                          info="Will show your 5th top spending category after analysis")
    
    # Generate Button
    gr.Markdown("""
    <div style="text-align: center; margin: 24px 0;">
        <p style="color: #7F8C8D; font-size: 14px; margin-bottom: 12px;">
            Upload your data, set your goals and budgets, then click below to generate insights
        </p>
    </div>
    """)
    with gr.Row():
        with gr.Column(scale=1):
            pass
        with gr.Column(scale=2):
            btn = gr.Button("üöÄ Generate Insights", variant="primary", size="lg", 
                           elem_classes=["generate-btn"])
        with gr.Column(scale=1):
            pass
    
    gr.Markdown("<br>")  # Spacing

    # KPI Cards - Enhanced styling
    with gr.Row():
        income = gr.Textbox(label="üí∞ Total Income", interactive=False, 
                           elem_classes=["kpi-card"], value="")
        spend = gr.Textbox(label="üí∏ Total Spending", interactive=False,
                          elem_classes=["kpi-card"], value="")
        net = gr.Textbox(label="üìà Net (Income - Spend)", interactive=False,
                        elem_classes=["kpi-card"], value="")

    # Visualizations - Better layout
    with gr.Row():
        with gr.Column(scale=1):
            cat_chart = gr.Plot(label="Spending by Category")
        with gr.Column(scale=1):
            trend_chart = gr.Plot(label="Income vs Spending Trend")
    
    # Goal Progress
    goal_chart = gr.Plot(label="Goal Progress")

    # Insights Tabs
    with gr.Tabs():
        with gr.Tab("ü§ñ AI Insights"):
            ai_insights = gr.Markdown(label="", elem_classes=["ai-insights-container"], value="")
        
        with gr.Tab("üß† Behavioral Insights"):
            behavioral_insights = gr.Markdown(label="Behavioral Analysis", value="")
        
        with gr.Tab("üí° Savings Opportunities"):
            opp_tbl = gr.Dataframe(label="Identified Savings Opportunities", 
                                  interactive=False)
        
        with gr.Tab("üí∞ Budget Tracking"):
            budget_tbl = gr.Dataframe(label="Budget vs Actual Spending", 
                                     interactive=False)
        
        with gr.Tab("üìã Details"):
            with gr.Row():
                with gr.Column():
                    subs_tbl = gr.Dataframe(label="üîî Detected Subscriptions", 
                                           interactive=False)
                    gray_charges_tbl = gr.Dataframe(label="‚ö†Ô∏è Gray Charges (Forgotten Free Trials)", 
                                                    interactive=False)
                    anom_tbl = gr.Dataframe(label="‚ö†Ô∏è Unusual Purchases", 
                                           interactive=False)
                with gr.Column():
                    cats_tbl = gr.Dataframe(label="üìä Top Spending Categories", 
                                           interactive=False)

    btn.click(run_pipeline, 
              inputs=[file, goal_name, goal_amount, goal_months,
                     budget_cat1, budget_cat2, budget_cat3, budget_cat4, budget_cat5],
              outputs=[income, spend, net, ai_insights, behavioral_insights,
                      cat_chart, trend_chart, goal_chart,
                      subs_tbl, gray_charges_tbl, anom_tbl, cats_tbl, opp_tbl, budget_tbl, top_categories_display,
                      budget_cat1, budget_cat2, budget_cat3, budget_cat4, budget_cat5])

# Launch the UI
print("\n" + "="*60)
print("‚úÖ Application ready! Opening browser...")
print("="*60)
print("\nAccess the UI at: http://localhost:7860")
print("Or: http://127.0.0.1:7860")
print("\nPress Ctrl+C to stop the server\n")

# For local use (accessible via localhost):
demo.launch(server_name="127.0.0.1", server_port=7860, share=False, show_error=True)

# For Colab or to create a public shareable link, use:
# demo.launch(share=True, server_name="0.0.0.0", server_port=7860, show_error=True)

